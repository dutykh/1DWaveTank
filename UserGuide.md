# 1DWaveTank: User Guide

**Author:**
- Dr. Denys Dutykh (Khalifa University of Science and Technology, Abu Dhabi, UAE)

**Contributors:**
- Prof. Mehmet ERSOY (SEATECH - École d'Ingénieurs de l'Université de Toulon, IMATH - Institut de Mathématiques de Toulon, France). The kinetic flux routine (+flux/Kinetic.m) is based on his original Fortran code and we gratefully acknowledge his scientific input and generosity in sharing this algorithm. Contact: http://ersoy.univ-tln.fr/

**Date:** April 20, 2025

## 1. Overview

`1DWaveTank` is a MATLAB-based numerical laboratory for simulating 1D long wave phenomena using the Finite Volume method. It provides a modular framework for experimenting with different numerical schemes, boundary conditions, and initial states for the **Non-Linear Shallow Water (NSW) equations**. The design prioritizes modularity, readability, and ease of extension, allowing users to readily test and integrate new components, even if this means sacrificing raw computational speed compared to highly optimized, monolithic codes.

The NSW equations solved here typically conserve mass and momentum, represented by the state variables:
* `H`: Water depth [m]
* `HU`: Discharge (or momentum) [m²/s]

This document details the structure, components, and usage of the `1DWaveTank` code.

## 2. Project Structure

The code is organised into MATLAB packages for modularity:

- **`+cfg`**: Configuration files and functions.
- **`+core`**: Core solver logic (`solver.m`) and RHS functions (`rhs_nsw_*.m`).
- **`+flux`**: Numerical flux functions (e.g., `HLLC.m`, `Rusanov.m`).
- **`+reconstruct`**: High-order reconstruction methods (e.g., `muscl.m`, `weno5.m`), supporting component-wise and characteristic-based (WENO5) approaches.
- **`+bc`**: Boundary condition implementations (e.g., `wall.m`, `open.m`).
- **`+ic`**: Initial condition setups (e.g., `lake_at_rest.m`).
- **`+time`**: Time integration schemes
- **`+vis`**: Visualisation tools
- **`+bathy`**: Bathymetry definition functions.
- **`+friction`**: Bottom friction models.
- **`run_simulation.m`**: Main script to execute a simulation
- **`README.md`**: Project overview and basic setup guide

## 3. Getting Started

1. **Configure:** Edit `+cfg/simulation_config.m` to select an `experiment_setup` (e.g., `'flat_rest'`, `'flat_gaussian'`, `'flat_wave_gen'`) and customise parameters like domain, mesh size (`N`), end time (`tEnd`), numerical flux (`numFlux`), time stepper (`timeStepper`), boundary conditions (`bc.left.handle`, `bc.right.handle`), initial condition (`ic_handle`), etc.
2. **Run:** Execute the main script:
   ```matlab
   run_simulation
   ```
3. **Observe:** The script displays simulation progress and animates the results. The final output is stored in the `results` structure.

## 4. Configuration (`+cfg`)

Configuration controls the simulation setup hierarchically: Defaults -> Experiment Setup -> User Overrides.

### 4.1. `default_config.m`

- Provides baseline parameters and default function handles.
- Called first by `simulation_config.m`.

### 4.2. `simulation_config.m`

- Main configuration file.
- Loads defaults and applies scenario-specific overrides.
- Sets mesh, time stepping, physical model, output path, etc.
- **Example Override:**
  ```matlab
  % Inside simulation_config.m, after loading defaults/setup:
  switch experiment_setup
      case 'flat_gaussian'
          % ... other settings ...
          config.tEnd = 10.0; % Override default end time
          config.numFlux = @flux.LaxFriedrichs; % Choose Lax-Friedrichs flux
          config.ic_param.a = 0.1; % Set IC parameter
          config.bathyHandle = @bathy.flat; % Set flat bathymetry
          config.icHandle = @ic.solitary_wave; % Set solitary wave IC
          % ...
  ```

### 4.3. `+bathy`

- Contains functions defining the bottom elevation `h(x)`.
- **`flat.m`**: Implements flat bathymetry:
  ```matlab
  function h = flat(x, cfg)
  ```

## 5. Core Components (`+core`)

### 5.1. `solver.m`

- Main simulation orchestrator.
- Sets IC, selects RHS, calls time integrator, computes `H`, `HU`, `U`.
- Returns results with metadata.

### 5.2. `rhs_nsw_1st_order.m`

- Computes RHS using 1st order FV scheme.
- Applies BCs, computes numerical fluxes, handles source terms.
- **Well-Balancing Note:** The bed slope source term is currently commented out. For simulations with non-flat bathymetry (`bathyHandle` is not `@bathy.flat`), implementing a **well-balanced** scheme (either by modifying the flux or the source term calculation) is crucial. This ensures that steady states (like a lake at rest over a varying bottom) are correctly maintained and prevents spurious flows generated by numerical imbalance between flux gradients and source terms.

### 5.3. `rhs_nsw_high_order.m`

- Computes RHS using a 2nd order FV scheme with MUSCL reconstruction.
- Requires a reconstruction method to be specified in `cfg.reconstruct`.
- Calls the selected reconstruction function (e.g., `@reconstruct.muscl` or `@reconstruct.muscl_characteristic`) to compute left and right states at cell interfaces.
- Applies BCs, computes numerical fluxes using reconstructed states, handles source terms.
- Suitable for use with higher-order time integrators (e.g., SSP2, SSP3, RK4).

### 5.4. Core Utilities (`+core/+utils`)

- `calculate_dt_cfl.m`, `get_bc_style.m`, `get_param.m`, `odetpbar.m`, `physical_flux.m`, `struct2str.m`, `textprogressbar.m`, `uniform.m`.

## 6. Numerical Fluxes (`+flux`)

Implemented schemes:

- `AUSM+.m`  (AUSM+ variant)
- `AUSMDV.m` (AUSM-Derivative Variant)
- `FORCE.m`
- `FVCF.m`
- `HLL.m`
- `HLLC.m`
- `LF.m`
- `LaxFriedrichs.m`
- `OsherSolomon.m`
- `Roe.m`
- `Rusanov.m`
- `StegerWarming.m`
- `HLLE.m`
- `SLAU.m`
- `CentralUpwind.m`: Central-Upwind (Kurganov-Noelle-Petrova) flux.
- `PVM.m`: Pressure Velocity Momentum flux (specific details TBD).
- `Kinetic.m`: Kinetic flux (contributed by Prof. Mehmet ERSOY, Université de Toulon, IMATH, based on original Fortran code).

All take `(wL, wR, cfg)` and return `[Flux_H, Flux_HU]`.

To use a specific flux, set the `config.numFlux` function handle in `+cfg/simulation_config.m`, for example:

```matlab
config.numFlux = @flux.HLLC; % Use the HLLC flux
```

## 7. High-Order Reconstruction (`+reconstruct`)

To achieve second-order spatial accuracy, the finite volume method requires reconstructing the solution within each cell to obtain distinct values at the left and right sides of cell interfaces. This package provides implementations for the MUSCL (Monotonic Upstream-centered Scheme for Conservation Laws) approach.

### Reconstruction Schemes (`+reconstruct`)

This package provides functions for higher-order spatial reconstruction of cell-averaged values to cell interfaces. This is essential for reducing numerical diffusion and capturing sharper gradients.

- **`weno5.m`**: Implements the 5th-order Weighted Essentially Non-Oscillatory (WENO5) scheme. It provides high accuracy while controlling spurious oscillations near discontinuities. It can reconstruct variables component-wise or use a characteristic decomposition (activated by `cfg.reconstruct.characteristic = true`) for improved stability, especially for systems like the shallow water equations.
- **`muscl.m`**: Implements the 2nd-order Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL). This is a widely used, robust scheme. It requires a slope limiter function (specified via `cfg.reconstruct.limiter`, e.g., `@reconstruct.limiters.minmod`) to prevent oscillations. Similar to WENO5, it can operate component-wise or use a characteristic decomposition (`cfg.reconstruct.characteristic = true`).
- **`ppm.m`**: Implements the 3rd-order Piecewise Parabolic Method (PPM). It offers high accuracy in smooth regions and robust shock-capturing. Supports both component-wise and characteristic-based reconstruction (controlled by `cfg.reconstruct.ppm_mode`). Requires `ng >= 2` ghost cells.
- **`+limiters`**: A sub-package containing various slope limiter functions (`minmod.m`, `vanleer.m`, `mc.m`, `superbee.m`) for use with the MUSCL scheme. The choice of limiter affects the scheme's accuracy and dissipative properties.

### 7.2. Slope Limiters (`+reconstruct/+limiters`)

Slope limiters modify the calculated slopes within each cell to prevent oscillations while maintaining accuracy. Several limiters are available:

- `minmod.m`: Basic, robust, but relatively dissipative.
- `mc.m`: Monotonized Central limiter.
- `koren.m`: Third-order accurate limiter.
- `ospre.m`: A smoother limiter.
- `umist.m`: UMIST limiter.
- `sweby.m`: Sweby limiter (parameterizable between minmod and superbee).
- `superbee.m`: Superbee limiter (less dissipative than minmod).
- `vanleer.m`: Van Leer's limiter.
- `vanalbada.m`: Van Albada limiter.

### 7.3. Configuration

To use high-order reconstruction:

1.  Set the RHS function to use the high-order solver:
    ```matlab
    config.model = @core.rhs_nsw_high_order;
    ```
2.  Specify the reconstruction method and limiter in the `cfg.reconstruct` structure:
    ```matlab
    % Option 1: Component-wise MUSCL with OSPRE limiter
    config.reconstruct.method = 'muscl';
    config.reconstruct.handle = @reconstruct.muscl;
    config.reconstruct.order = 2;
    config.reconstruct.limiter = @reconstruct.limiters.ospre;

    % Option 2: Component-wise ENO2
    config.reconstruct.method = 'eno2';
    config.reconstruct.handle = @reconstruct.eno2;
    config.reconstruct.order = 2;
    config.model = @core.rhs_nsw_high_order;
    config.timeStepper = @time.integrate_ssp2_adaptive; % Need >= 2nd order time stepper

    % Option 3: Characteristic MUSCL with Koren limiter
    config.reconstruct.method = 'muscl_characteristic';
    config.reconstruct.handle = @reconstruct.muscl_characteristic;
    config.reconstruct.order = 2;
    config.reconstruct.limiter = @reconstruct.limiters.koren;

    % Option 4: UNO2 Reconstruction
    config.reconstruct.method = 'uno2';
    config.reconstruct.handle = @reconstruct.uno2;
    config.reconstruct.order = 2;
    % Limiter is not specified for UNO2 as it's built-in

    % Option 5: WENO5 Reconstruction
    config.reconstruct.method = 'weno5';
    config.reconstruct.handle = @reconstruct.weno5;
    config.reconstruct.order = 5;
    % Limiter is not specified for WENO5 as it's built-in
    ```
3.  Choose a suitable time integrator (e.g., `@time.integrate_ssp2_adaptive`).

## 8. Boundary Conditions (`+bc`)

Boundary conditions define how the simulation behaves at the edges of the domain (`xmin` and `xmax`). They are set using function handles in `cfg.bc.left.handle` and `cfg.bc.right.handle`.

*   **`@bc.wall`:** Simulates a solid, impermeable wall. This is the default condition. It sets the velocity (HU) to zero in the ghost cells and reflects the water height (H).
*   **`@bc.generating`:** Simulates a wave generation boundary. Currently configured for sinusoidal waves based on amplitude (`cfg.bc.left.param.a` or `cfg.bc.right.param.a`) and frequency (`cfg.bc.left.param.omega` or `cfg.bc.right.param.omega`).
*   **`@bc.periodic`:** Connects the left and right boundaries, treating the domain as if it wraps around. Values leaving one side enter the other. To use periodic conditions, *both* `cfg.bc.left.handle` and `cfg.bc.right.handle` must be set to `@bc.periodic`.

Example configuration for periodic BCs:
```matlab
cfg.bc.left.handle = @bc.periodic;
cfg.bc.right.handle = @bc.periodic;
```

## 9. Initial Conditions (`+ic`)

Defines the initial state (`H`, `HU`) at `t=0`.

- `gaussian_bump.m`: Gaussian perturbation on a lake at rest.
- `lake_at_rest.m`: Constant water depth, zero velocity. Uses param.H0.
- `solitary_wave.m`: Solitary wave initial condition.
- `dam_break.m`: Piecewise constant initial water level. Uses `cfg.dam_break.h_L`, `cfg.dam_break.h_R`, `cfg.dam_break.x_dam`.

Signature:
```matlab
function w0 = ic_function(xc, cfg)
```

## 10. Bathymetry (`+bathy`)

Bathymetry functions define the bottom elevation `h(x)`.

- `flat.m`: Flat bathymetry (constant depth `cfg.param.H0`).

Signature:
```matlab
function h = bathy_function(x, cfg)
```

## 11. Friction Models (`+friction`)

The 1DWaveTank code supports various friction models through the `+friction` package. By default, no friction is applied.

### Available Models

* **No Friction** (default): `config.phys.friction_model = @friction.no_friction`
* **Chézy**: `config.phys.friction_model = friction.friction_selector('chezy')`
  * Requires: `config.phys.chezy_C` (typical values: 30-90 m^(1/2)/s)
* **Manning**: `config.phys.friction_model = friction.friction_selector('manning')`
  * Requires: `config.phys.manning_n` (typical values: 0.01-0.05 s/m^(1/3))
  * Common values:
    * 0.01-0.02: Very smooth channels (concrete, metal)
    * 0.025-0.035: Clean, straight natural channels
    * 0.04-0.07: Natural channels with vegetation, stones
    * 0.08-0.15: Very rough channels with heavy vegetation
* **Darcy-Weisbach**: `config.phys.friction_model = friction.friction_selector('darcy_weisbach')`
  * With constant friction factor:
    * Set `config.phys.darcy_f` (typical values: 0.01-0.05)
  * With Colebrook-White formula (variable friction factor):
    * Set `config.phys.f_calculation = 'colebrook_white'`
    * Set `config.phys.ks` - Equivalent sand roughness [m]
    * Set `config.phys.kinematic_viscosity` - Kinematic viscosity [m²/s]
    * Optional: `config.phys.cw_iterations`, `config.phys.cw_tolerance`

### Using Friction in Simulations

To enable a friction model, add these lines to your configuration in `simulation_config.m`:

```matlab
% Option 1: Chézy model
config.phys.friction_model = friction.friction_selector('chezy');
config.phys.chezy_C = 50;  % Chézy coefficient [m^(1/2)/s]

% Option 2: Manning model
config.phys.friction_model = friction.friction_selector('manning');
config.phys.manning_n = 0.03;  % Manning coefficient [s/m^(1/3)]

% Option 3: Darcy-Weisbach with constant friction factor
config.phys.friction_model = friction.friction_selector('darcy_weisbach');
config.phys.darcy_f = 0.02;  % Constant Darcy friction factor

% Option 4: Darcy-Weisbach with Colebrook-White formula
config.phys.friction_model = friction.friction_selector('darcy_weisbach');
config.phys.f_calculation = 'colebrook_white';
config.phys.ks = 0.001;  % Equivalent sand roughness [m]
config.phys.kinematic_viscosity = 1e-6;  % Kinematic viscosity [m²/s]
```

### Adding New Friction Models

To add a new friction model:

1. Create a new file in `+friction/` (e.g., `manning.m`)
2. Implement the friction model with the standard interface: `friction_term = model_name(H, HU, g, cfg)`
3. Add the model to `friction_selector.m`
4. Update documentation

## 12. Time Integration (`+time`)

### Custom Adaptive Steppers

- `integrate_ab2_adaptive.m`: 2nd-order Adams-Bashforth.
- `integrate_bogacki_shampine.m`: 3(2) embedded Runge-Kutta (Bogacki-Shampine).
- `integrate_dopri54_adaptive.m`: 5(4) embedded Runge-Kutta (Dormand-Prince).
- `integrate_euler_adaptive.m`: Forward Euler.
- `integrate_rk4_adaptive.m`: 4th-order Runge-Kutta.
- `integrate_ssp2_adaptive.m`: 2nd-order SSP Runge-Kutta.
- `integrate_ssp3_adaptive.m`: 3rd-order SSP Runge-Kutta.

All follow signature:
```matlab
function [sol_out, t_out, stats] = integrate_...(rhs_func, tspan, w0, cfg)
```

### MATLAB Solver Wrapper

- `integrate_matlab_ode.m`
- Uses `cfg.time.matlab_solver`, `AbsTol`, `RelTol`, `ode_options`
- Uses internal error control for time stepping (not CFL)

## 13. Visualisation (`+vis`)

### `plot_state.m`

- Plots water surface and bathymetry.
- Optionally plots velocity.
- Handles figure updating and axis management.
- Used by `run_simulation.m` for animation.

## 14. Main Script (`run_simulation.m`)

- Clears environment, adds paths.
- Loads config and runs the simulation.
- Calls visualisation tools.
- Prints CPU time and global statistics.

## 15. Requirements

- MATLAB (developed and tested on recent versions, e.g., R2020a and later, but may work on older versions).
- No specific toolboxes are required for the core functionality.

## 16. Extensibility

The modular structure using MATLAB packages makes it easy to add new components, aligning with the project's goal of providing a clear and adaptable framework for numerical experimentation:

- **New Flux:** Add a function to `+flux/`, e.g., `F = my_flux(wL, wR, cfg)` and select via `cfg.numFlux = @flux.my_flux;`.
- **New BC:** Add a function to `+bc/`, e.g., `w_padded = my_bc(w_padded, t, side, cfg, num_ghost_cells)` and use `cfg.bc.left.handle = @bc.my_bc;`.
- **New IC:** Add a function to `+ic/`, e.g., `w0 = my_ic(xc, cfg)` and use `cfg.icHandle = @ic.my_ic;`.
- **New Time Stepper:** Add a function to `+time/`, e.g., `integrate_my_scheme`, and use `cfg.timeStepper = @time.integrate_my_scheme;`.
- **New Bathymetry:** Add a function to `+bathy/`, e.g., `h = my_bathy(x, cfg)` and use `bathyHandle = @bathy.my_bathy;`. Ensure well-balanced scheme support for non-flat beds.
- **New Reconstruction Method:** Add a function to `+reconstruct/`, e.g., `[wL, wR] = my_recon(w_pad, cfg)` and use `cfg.reconstruct.handle = @reconstruct.my_recon;`. Update `+reconstruct/reconstruct_selector.m` to include your method.
- **New Slope Limiter:** Add a function to `+reconstruct/+limiters/`, e.g., `slope = my_limiter(dm, dp)` and use `cfg.reconstruct.limiter = @reconstruct.limiters.my_limiter;`. Update `+reconstruct/reconstruct_selector.m` to include your limiter. Note that methods like UNO2 do not require separate limiters.

### Available Experiment Setups

The `+cfg/simulation_config.m` script allows selecting pre-defined experiment setups by changing the `experiment_setup` variable.

*   **`'flat_rest'`:** Flat bathymetry, water initially at rest (`h0`). Wall boundaries.
*   **`'flat_gaussian'`:** Flat bathymetry, Gaussian pulse initial condition. Wall boundaries.
*   **`'flat_wave_gen'`:** Flat bathymetry, generating boundary on the left, wall on the right.
*   **`'flat_solitary'`:** Flat bathymetry, solitary wave initial condition. Wall boundaries.
*   **`'periodic_solitary'`:** Flat bathymetry, solitary wave initial condition. Periodic boundaries on both left and right.
*   **`'dam_break'`:** Flat bathymetry, piecewise constant initial water level. Wall boundaries. Simulates the breaking of a dam.

Each case sets the appropriate `bathyHandle`, `icHandle`, and `bc` handles, and defines a descriptive `case_name` for output files.