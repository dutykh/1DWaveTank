# 1DWaveTank: User Guide

**Author:** Dr. Denys Dutykh (Khalifa University of Science and Technology, Abu Dhabi, UAE)  
**Date:** April 20, 2025

## 1. Overview

`1DWaveTank` is a MATLAB-based numerical laboratory for simulating 1D long wave phenomena using the Finite Volume method. It provides a modular framework for experimenting with different numerical schemes, boundary conditions, and initial states for the **Non-Linear Shallow Water (NSW) equations**. The design prioritizes modularity, readability, and ease of extension, allowing users to readily test and integrate new components, even if this means sacrificing raw computational speed compared to highly optimized, monolithic codes.

The NSW equations solved here typically conserve mass and momentum, represented by the state variables:
* `H`: Water depth [m]
* `HU`: Discharge (or momentum) [mÂ²/s]

This document details the structure, components, and usage of the `1DWaveTank` code.

## 2. Project Structure

The code is organised into MATLAB packages for modularity:

- **`+cfg`**: Configuration files and functions
- **`+core`**: Core solver logic and RHS (Right-Hand Side) functions
- **`+flux`**: Numerical flux implementations for the finite volume method
- **`+bc`**: Boundary condition implementations
- **`+ic`**: Initial condition setups
- **`+time`**: Time integration schemes
- **`+vis`**: Visualisation tools
- **`run_simulation.m`**: Main script to execute a simulation
- **`README.md`**: Project overview and basic setup guide

## 3. Getting Started

1. **Configure:** Edit `+cfg/simulation_config.m` to select an `experiment_setup` (e.g., `'flat_rest'`, `'flat_gaussian'`, `'flat_wave_gen'`) and customise parameters like domain, mesh size (`N`), end time (`tEnd`), numerical flux (`numFlux`), time stepper (`timeStepper`), boundary conditions (`bc.left.handle`, `bc.right.handle`), initial condition (`ic_handle`), etc.
2. **Run:** Execute the main script:
   ```matlab
   run_simulation
   ```
3. **Observe:** The script displays simulation progress and animates the results. The final output is stored in the `results` structure.

## 4. Configuration (`+cfg`)

Configuration controls the simulation setup hierarchically: Defaults -> Experiment Setup -> User Overrides.

### 4.1. `default_config.m`

- Provides baseline parameters and default function handles.
- Called first by `simulation_config.m`.

### 4.2. `simulation_config.m`

- Main configuration file.
- Loads defaults and applies scenario-specific overrides.
- Sets mesh, time stepping, physical model, output path, etc.
- **Example Override:**
  ```matlab
  % Inside simulation_config.m, after loading defaults/setup:
  switch experiment_setup
      case 'flat_gaussian'
          % ... other settings ...
          config.tEnd = 10.0; % Override default end time
          config.numFlux = @flux.Roe; % Choose Roe flux
          config.ic_param.a = 0.1; % Set IC parameter
          % ...
  ```

### 4.3. `+cfg/+bathy`

- **`flat.m`**: Implements flat bathymetry:
  ```matlab
  function h = flat(x, cfg)
  ```

## 5. Core Components (`+core`)

### 5.1. `solver.m`

- Main simulation orchestrator.
- Sets IC, selects RHS, calls time integrator, computes `H`, `HU`, `U`.
- Returns results with metadata.

### 5.2. `rhs_nsw_1st_order.m`

- Computes RHS using 1st order FV scheme.
- Applies BCs, computes numerical fluxes, handles source terms.
- **Well-Balancing Note:** The bed slope source term is currently commented out. For simulations with non-flat bathymetry (`cfg.bathyHandle` is not `@cfg.bathy.flat`), implementing a **well-balanced** scheme (either by modifying the flux or the source term calculation) is crucial. This ensures that steady states (like a lake at rest over a varying bottom) are correctly maintained and prevents spurious flows generated by numerical imbalance between flux gradients and source terms.

### 5.3. Core Utilities (`+core/+utils`)

- `calculate_dt_cfl.m`, `get_bc_style.m`, `get_param.m`, `odetpbar.m`, `physical_flux.m`, `struct2str.m`, `textprogressbar.m`, `uniform.m`.

## 6. Numerical Fluxes (`+flux`)

Implemented schemes:

- `AUSM+.m`  (AUSM+ variant)
- `AUSMDV.m` (AUSM-Derivative Variant)
- `FORCE.m`
- `FVCF.m`
- `HLL.m`
- `HLLC.m`
- `LF.m`
- `OsherSolomon.m`
- `Roe.m`
- `Rusanov.m`
- `StegerWarming.m`

All take `(wL, wR, cfg)` and return `[Flux_H, Flux_HU]`.

## 7. Boundary Conditions (`+bc`)

Boundary condition functions:

- `generating.m`: Wave generating boundary using sine wave (cfg.bc.(side).param.a, T) and Riemann invariants.
- `open.m`: Open (zeroth-order extrapolation) boundary.
- `wall.m`: Solid wall (reflective) boundary (HU_ghost = -HU_interior).

Signature:
```matlab
function w_padded = bc_function(w_padded, t, side, cfg, num_ghost_cells)
```

## 8. Initial Conditions (`+ic`)

Initial condition functions:

- `gaussian_bump.m`: Gaussian water surface bump, zero velocity. Uses param.a, lambda, x0, H0.
- `lake_at_rest.m`: Constant water depth, zero velocity. Uses param.H0.

Signature:
```matlab
function w0 = ic_function(xc, cfg)
```

## 9. Time Integration (`+time`)

### Custom Adaptive Steppers

- `integrate_ab2_adaptive.m`: 2nd-order Adams-Bashforth.
- `integrate_euler_adaptive.m`: Forward Euler.
- `integrate_rk4_adaptive.m`: 4th-order Runge-Kutta.
- `integrate_ssp2_adaptive.m`: 2nd-order SSP Runge-Kutta.
- `integrate_ssp3_adaptive.m`: 3rd-order SSP Runge-Kutta.

All follow signature:
```matlab
function [sol_out, t_out, stats] = integrate_...(rhs_func, tspan, w0, cfg)
```

### MATLAB Solver Wrapper

- `integrate_matlab_ode.m`
- Uses `cfg.time.matlab_solver`, `AbsTol`, `RelTol`, `ode_options`
- Uses internal error control for time stepping (not CFL)

## 10. Visualisation (`+vis`)

### `plot_state.m`

- Plots water surface and bathymetry.
- Optionally plots velocity.
- Handles figure updating and axis management.
- Used by `run_simulation.m` for animation.

## 11. Main Script (`run_simulation.m`)

- Clears environment, adds paths.
- Loads config and runs the simulation.
- Calls visualisation tools.
- Prints CPU time and global statistics.

## 12. Requirements

- MATLAB (developed and tested on recent versions, e.g., R2020a and later, but may work on older versions).
- No specific toolboxes are required for the core functionality.

## 13. Extensibility

The modular structure using MATLAB packages makes it easy to add new components, aligning with the project's goal of providing a clear and adaptable framework for numerical experimentation:

- **New Flux:** Add a function to `+flux/`, e.g., `F = my_flux(wL, wR, cfg)` and select via `cfg.numFlux = @flux.my_flux;`.
- **New BC:** Add a function to `+bc/`, e.g., `w_padded = my_bc(w_padded, t, side, cfg, num_ghost_cells)` and use `cfg.bc.left.handle = @bc.my_bc;`.
- **New IC:** Add a function to `+ic/`, e.g., `w0 = my_ic(xc, cfg)` and use `cfg.ic_handle = @ic.my_ic;`.
- **New Time Stepper:** Add a function to `+time/`, e.g., `integrate_my_scheme`, and use `cfg.timeStepper = @time.integrate_my_scheme;`.
- **New Bathymetry:** Add a function to `+cfg/+bathy/`, e.g., `h = my_bathy(x, cfg)` and use `cfg.bathyHandle = @cfg.bathy.my_bathy;`. Ensure well-balanced scheme support for non-flat beds.